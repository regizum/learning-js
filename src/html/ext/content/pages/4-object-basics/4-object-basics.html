<div class="container mt-5">
    <h1>Объекты: основы</h1>
    <div class="card mb-3" id="object">
        <div class="card-header d-flex align-items-center">
            <h2 class="h5 mb-0">4.1 Объекты</h2>
            <div class="dropdown ml-auto">
                <button
                        class="btn btn-primary dropdown-toggle"
                        type="button"
                        id="dropdownMenuButton1"
                        data-toggle="dropdown"
                        aria-haspopup="true"
                        aria-expanded="false">
                    Homeworks
                </button>
                <div class="dropdown-menu" aria-labelledby="dropdownMenuButton1">
                    <a
                            class="dropdown-item"
                            target="_blank"
                            href="./homeworks/4/4-1-1.html"
                    >1</a
                    ><a
                        class="dropdown-item"
                        target="_blank"
                        href="./homeworks/4/4-1-2.html"
                >2</a><a
                        class="dropdown-item"
                        target="_blank"
                        href="./homeworks/4/4-1-3.html"
                >3</a><a
                        class="dropdown-item"
                        target="_blank"
                        href="./homeworks/4/4-1-4.html"
                >4</a>
                </div>
            </div>
            <div class="ml-4">
                <a href="https://learn.javascript.ru/object" target="_blank"
                >Link</a
                >
            </div>
        </div>
        <div class="card-body">
            <p>Объекты – это ассоциативные массивы с рядом дополнительных возможностей.</p>
            <p>Они хранят свойства (пары ключ-значение), где:</p>
            <ul>
                <li>Ключи свойств должны быть строками или символами (обычно строками).</li>
                <li>Значения могут быть любого типа.</li>
                <li>Имя переменной не может совпадать с зарезервированными словами, такими как «for», «let»,
                    «return» и
                    т.д. Но для свойств объекта такого ограничения нет
                </li>
            </ul>
            <p>Чтобы получить доступ к свойству, мы можем использовать:</p>
            <ul>
                <li>Запись через точку: <code>obj.property</code>.</li>
                <li>Квадратные скобки <code>obj["property"]</code>. Квадратные скобки позволяют взять ключ из
                    переменной, например, <code>obj[varWithKey]</code>.
                </li>
            </ul>
            <h3 class="h5">Вычисляемые свойства</h3>
            <pre><code>let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
            </code></pre>
            <h3 class="h5">Свойство из переменной</h3>
            <pre><code>function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}</code></pre>
            <h3 class="h5">Дополнительные операторы:</h3>
            <ul>
                <li>Удаление свойства: <code>delete obj.prop</code>.</li>
                <li>Проверка существования свойства: <code>"key" in obj</code>.</li>
                <li>Перебор свойств объекта: цикл for <code>for (let key in obj)</code>.</li>
            </ul>
            <p>То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто
                <code>Object</code>.</p>
            <h3 class="h5">В JavaScript есть много других типов объектов:</h3>
            <ul>
                <li><code>Array</code> для хранения упорядоченных коллекций данных,</li>
                <li><code>Date</code> для хранения информации о дате и времени,</li>
                <li><code>Error</code> для хранения информации об ошибке.</li>
                <li>… и так далее.</li>
            </ul>
            <p class="mb-0">Иногда люди говорят что-то вроде «тип
                данных Array»
                или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных
                <code>Object</code>.
                Они лишь расширяют его различными способами.</p>
        </div>
    </div>
    <div class="card mb-3" id="object-copy">
        <div class="card-header d-flex align-items-center">
            <h2 class="h5 mb-0">4.2 Копирование объектов и ссылки</h2>
            <div class="ml-auto">
                <a href="https://learn.javascript.ru/object-copy" target="_blank"
                >Link</a
                >
            </div>
        </div>
        <div class="card-body">
            <p>Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а
                «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в
                качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.</p>

            <h3 class="h5">Сравнение по ссылке</h3>
            <p>Операторы равенства == и строгого равенства === для объектов работают одинаково.</p>
            <p>Два объекта равны только в том случае, если это один и тот же объект.</p>

            <h3 class="h5">Клонирование и объединение объектов, Object.assign</h3>
            <pre><code>Object.assign(dest, [src1, src2, src3...])</code></pre>
            <ul class="mb-0">
                <li>Первый аргумент <code>dest</code> — целевой объект.</li>
                <li>Остальные аргументы <code>src1, ..., srcN</code> (может быть столько, сколько нужно)) являются
                    исходными объектами
                </li>
                <li>Метод копирует свойства всех исходных объектов <code>src1, ..., srcN</code> в целевой объект <code>dest</code>.
                    То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
                </li>
                <li>Возвращает объект <code>dest</code>.</li>
                <li>Необходимо помнить, что Object.assign не делает глубокое клонирования объекта. Если внутри
                    копируемого объекта есть свойство значение, которого не является примитивом, оно будет передано по
                    ссылке. Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом из
                    сторонней JavaScript-библиотеки _.cloneDeep(obj).
                </li>
            </ul>
        </div>
    </div>

    <div class="card mb-3" id="garbage-collection">
        <div class="card-header d-flex align-items-center">
            <h2 class="h5 mb-0">4.3 Сборка мусора</h2>
            <div class="ml-auto">
                <a href="https://learn.javascript.ru/garbage-collection" target="_blank"
                >Link</a
                >
            </div>
        </div>
        <div class="card-body">
            <ul>
                <li>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.</li>
                <li>Объекты сохраняются в памяти, пока они достижимы.</li>
                <li>Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов
                    могут стать недостижимыми как единое целое.
                </li>
            </ul>
            <p>Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не
                влияла на производительность.</p>
            <p>Вот некоторые из оптимизаций:</p>
            <ul class="mb-0">
                <li><strong>Сборка по поколениям (Generational collection)</strong> – объекты делятся на «новые» и
                    «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более
                    агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
                </li>
                <li><strong>Инкрементальная сборка (Incremental collection)</strong> – если объектов много, то обход
                    всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым
                    задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно.
                    Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания
                    изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
                </li>
                <li><strong>Сборка в свободное время (Idle-time collection)</strong> – чтобы уменьшить возможное влияние
                    на производительность, сборщик мусора старается работать только во время простоя процессора.
                </li>
            </ul>
        </div>
    </div>
</div>
