<div class="container mt-5">
  <h1>Продвинутая работа с функциями</h1>
  <div class="card mb-3" id="recursion">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.1 Рекурсия и стек</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton1"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton1">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-1-1.html"
            >1</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-1-2.html"
            >2</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-1-3.html"
            >3</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-1-4.html"
            >4</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-1-5.html"
            >5</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a href="https://learn.javascript.ru/recursion" target="_blank">Link</a>
      </div>
    </div>
    <div class="card-body">
      <p>Термины:</p>
      <ul>
        <li>
          <p>
            <em>Рекурсия</em> – это термин в программировании, означающий вызов
            функцией самой себя. Рекурсивные функции могут быть использованы для
            элегантного решения определённых задач.
          </p>
          <p>
            Когда функция вызывает саму себя, это называется
            <em>шагом рекурсии</em>. <em>База</em> рекурсии – это такие
            аргументы функции, которые делают задачу настолько простой, что
            решение не требует дальнейших вложенных вызовов.
          </p>
        </li>
        <li>
          <p>
            <a href="https://en.wikipedia.org/wiki/Recursive_data_type"
              >Рекурсивно определяемая</a
            >
            структура данных – это структура данных, которая может быть
            определена с использованием самой себя.
          </p>
          <p>
            Например, связанный список может быть определён как структура
            данных, состоящая из объекта, содержащего ссылку на список (или
            null).
          </p>
          <pre><code>list = { value, next -> list }</code></pre>
          <p>
            Деревья, такие как дерево HTML-элементов или дерево отделов из этой
            главы, также являются рекурсивными: они разветвляются, и каждая
            ветвь может содержать другие ветви.
          </p>
          <p>
            Как мы видели в примере <code>sumSalary</code>, рекурсивные функции
            могут быть использованы для прохода по ним.
          </p>
        </li>
      </ul>
      <p>
        Любая рекурсивная функция может быть переписана в итеративную. И это
        иногда требуется для оптимизации работы. Но для многих задач рекурсивное
        решение достаточно быстрое и простое в написании и поддержке.
      </p>
    </div>
  </div>
  <div class="card mb-3" id="rest-parameters-spread-operator">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.2 Остаточные параметры и оператор расширения</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton2"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton2">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-2-1.html"
            >1</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a
          href="https://learn.javascript.ru/rest-parameters-spread-operator"
          target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <p>
        Когда мы видим <code>"..."</code> в коде, это могут быть как остаточные
        параметры, так и оператор расширения.
      </p>
      <p>Как отличить их друг от друга:</p>
      <ul>
        <li>
          Если <code>...</code> располагается в конце списка аргументов функции,
          то это «остаточные параметры». Он собирает остальные неуказанные
          аргументы и делает из них массив.
          <pre><code>function sumAll(...args) { // args — имя массива
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6</code></pre>
        </li>
        <li>
          Если <code>...</code> встретился в вызове функции или где-либо ещё, то
          это «оператор расширения». Он извлекает элементы из массива.
          <pre><code>let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25</code></pre>
        </li>
      </ul>
      <p>Полезно запомнить:</p>
      <ul>
        <li>
          Остаточные параметры используются, чтобы создавать новые функции с
          неопределённым числом аргументов.
        </li>
        <li>
          С помощью оператора расширения можно вставить массив в функцию,
          которая по умолчанию работает с обычным списком аргументов.
        </li>
      </ul>
      <p>
        К аргументам функции можно обращаться и по-старому — через псевдомассив
        <code>arguments</code>. Стрелочные функции не имеют "arguments". Хотя
        arguments похож на массив, и его тоже можно перебирать, это всё же не
        массив.
      </p>
      <pre><code>function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // Объект arguments можно перебирать
  // for (let arg of arguments) alert(arg);
}

// Вывод: 2, Юлий, Цезарь
showName("Юлий", "Цезарь");

// Вывод: 1, Илья, undefined (второго аргумента нет)
showName("Илья");</code></pre>
    </div>
  </div>
  <div class="card mb-3" id="closure">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.3 Замыкание</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton3"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton3">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-3-1.html"
            >1</a
          >
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-3-2.html"
            >2</a
          >
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-3-3.html"
            >3</a
          >
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-3-4.html"
            >4</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a href="https://learn.javascript.ru/closure" target="_blank">Link</a>
      </div>
    </div>
    <div class="card-body">
      <p>Объект лексического окружения состоит из двух частей:</p>
      <ol>
        <li>
          <p>
            <em>Environment Record</em> – объект, в котором как свойства
            хранятся все локальные переменные (а также некоторая другая
            информация, такая как значение <code>this</code>).
          </p>
        </li>
        <li>
          <p>
            Ссылка на <em>внешнее лексическое окружение</em> – то есть то,
            которое соответствует коду снаружи (снаружи от текущих фигурных
            скобок).
          </p>
        </li>
      </ol>
      <p>
        Когда код хочет получить доступ к переменной – сначала происходит поиск
        во внутреннем лексическом окружении, затем во внешнем, затем в следующем
        и так далее, до глобального.
      </p>
      <p>
        Функция получает текущее значение внешних переменных, то есть, их
        последнее значение
      </p>
      <pre><code>let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete"; // (*)

sayHi(); // Pete</code></pre>
      <p>
        <strong
          >"Переменная" – это просто свойство специального внутреннего объекта:
          Environment Record. «Получить или изменить переменную», означает,
          «получить или изменить свойство этого объекта».</strong
        >
      </p>
      <h3 class="h5">Function Declaration</h3>
      <p>
        До сих пор мы рассматривали только переменные. Теперь рассмотрим
        Function Declaration. В отличие от переменных, объявленных с помощью
        let, они полностью инициализируются не тогда, когда выполнение доходит
        до них, а раньше, когда создаётся лексическое окружение.
      </p>
      <p>
        Для каждого вызова makeCounter() создаётся новое лексическое окружение
        функции, со своим собственным count. Так что, получившиеся функции
        counter – независимы.
      </p>
      <pre><code>function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert( counter1() ); // 0
alert( counter1() ); // 1

alert( counter2() ); // 0 (независимо)</code></pre>
      <h3 class="h5">Блоки кода и циклы, IIFE</h3>
      <ol>
        <li>
          <p><strong>If</strong></p>
          <p>
            Когда выполнение попадает в блок if, для этого блока создаётся новое
            лексическое окружение.
          </p>
        </li>
        <li>
          <p><strong>For, while</strong></p>
          <p>
            Для цикла у каждой итерации своё отдельное лексическое окружение.
            Если переменная объявлена в for(let ...), то она также в нём:
          </p>
        </li>
        <li>
          <p><strong>Блоки кода</strong></p>
          <p>
            Мы также можем использовать «простые» блоки кода {...}, чтобы
            изолировать переменные в «локальной области видимости».
          </p>
          <pre><code>{
  // сделать какую-нибудь работу с локальными переменными, которые не должны быть видны снаружи

  let message = "Hello";

  alert(message); // Hello
}

alert(message); // Ошибка: переменная message не определена</code></pre>
        </li>
        <li>
          <p>
            <strong>IIFE «immediately-invoked function expressions»</strong>
          </p>
          <p>
            В прошлом в JavaScript не было лексического окружения на уровне
            блоков кода. Так что программистам пришлось что-то придумать. И то,
            что они сделали, называется «immediately-invoked function
            expressions» (аббревиатура IIFE), что означает функцию, запускаемую
            сразу после объявления. Это не то, что мы должны использовать
            сегодня.
          </p>
          <pre><code>(function() {

  let message = "Hello";

  alert(message); // Hello

})();</code></pre>
        </li>
      </ol>
    </div>
  </div>
  <div class="card mb-3" id="var">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.4 Устаревшее ключевое слово "var"</h2>
      <div class="ml-auto">
        <a href="https://learn.javascript.ru/var" target="_blank">Link</a>
      </div>
    </div>
    <div class="card-body">
      <p>
        Существует 2 основных отличия <code>var</code> от
        <code>let/const</code>:
      </p>
      <ol class="mb-0">
        <li>
          Переменные <code>var</code> не имеют блочной области видимости, они
          ограничены, как минимум, телом функции.
        </li>
        <li>
          Объявления (инициализация) переменных <code>var</code>производится в
          начале исполнения функции (или скрипта для глобальных переменных).
        </li>
      </ol>
    </div>
  </div>
  <div class="card mb-3" id="global-object">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.5 Глобальный объект</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton5"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton5">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-5-1.html"
            >1</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a href="https://learn.javascript.ru/global-object" target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <ul>
        <li>
          <p>
            Глобальный объект хранит переменные, которые должны быть доступны в
            любом месте программы.
          </p>
          <p>
            Это включает в себя как встроенные объекты, например,
            <code>Array</code>, так и характерные для окружения свойства,
            например, <code>window.innerHeight</code> – высота окна браузера.
          </p>
        </li>
        <li>
          <p>
            Глобальный объект имеет универсальное имя – <code>globalThis</code>.
          </p>
          <p>
            …Но чаще на него ссылаются по-старому, используя имя, характерное
            для данного окружения, такое как <code>window</code> (браузер) и
            <code>global</code> (Node.js). Так как
            <code>globalThis</code> появился недавно, он не поддерживается в IE
            и Edge (не-Chromium версия), но можно использовать полифил.
          </p>
        </li>
        <li>
          <p>
            Следует хранить значения в глобальном объекте, только если они
            действительно глобальны для нашего проекта. И стараться свести их
            количество к минимуму.
          </p>
        </li>
        <li>
          <p>
            В браузерах, если только мы не используем
            <a href="/modules">модули</a>, глобальные функции и переменные,
            объявленные с помощью <code>var</code>, становятся свойствами
            глобального объекта.
          </p>
        </li>
        <li>
          <p>
            Для того, чтобы код был проще и в будущем его легче было
            поддерживать, следует обращаться к свойствам глобального объекта
            напрямую, как <code>window.x</code>.
          </p>
        </li>
      </ul>
    </div>
  </div>
  <div class="card mb-3" id="function-object">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.6 Объект функции, NFE</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton6"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton6">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-6-1.html"
            >1</a
          >
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-6-2.html"
            >2</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a href="https://learn.javascript.ru/function-object" target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <p>Функции – это объекты.</p>
      <p>Их свойства:</p>
      <ul>
        <li>
          <code>name</code> – имя функции. Обычно берётся из объявления функции,
          но если там нет – JavaScript пытается понять его из контекста.
        </li>
        <li>
          <code>length</code> – количество аргументов в объявлении функции.
          Троеточие («остаточные параметры») не считается.
        </li>
      </ul>
      <p>
        Если функция объявлена как Function Expression (вне основного потока
        кода) и имеет имя, тогда это называется Named Function Expression
        (Именованным Функциональным Выражением). Это имя может быть использовано
        для ссылки на себя же, для рекурсивных вызовов и т.п.
      </p>
      <pre><code>let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // Теперь всё в порядке
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вложенный вызов работает)</code></pre>
      <p>
        Также функции могут содержать дополнительные свойства. Многие известные
        JavaScript-библиотеки искусно используют эту возможность.
      </p>
      <pre><code>function makeCounter() {
  // вместо
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1</code></pre>
      <p>
        Они создают «основную» функцию и добавляют множество «вспомогательных»
        функций внутрь первой. Например, библиотека
        <a href="https://jquery.com">jQuery</a> создаёт функцию с именем
        <code>$</code>. Библиотека
        <a href="https://lodash.com">lodash</a> создаёт функцию <code>_</code>,
        а потом добавляет в неё <code>_.clone</code>, <code>_.keyBy</code> и
        другие свойства (чтобы узнать о ней побольше см.
        <a href="https://lodash.com/docs">документацию</a>). Они делают это,
        чтобы уменьшить засорение глобального пространства имён посредством
        того, что одна библиотека предоставляет только одну глобальную
        переменную, уменьшая вероятность конфликта имён.
      </p>
      <p>
        Таким образом, функция может не только делать что-то сама по себе, но
        также и предоставлять полезную функциональность через свои свойства.
      </p>
      <pre class="mb-0"><code>function sum(a) {
  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert(sum(1)(2)); // 3
alert(sum(5)(-1)(2)); // 6
alert(sum(6)(-1)(-2)(-3)); // 0
alert(sum(0)(1)(2)(3)(4)(5)); // 15</code></pre>
    </div>
  </div>
  <div class="card mb-3" id="new-function">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.7 Синтаксис "new Function"</h2>

      <div class="ml-auto">
        <a href="https://learn.javascript.ru/function-object" target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <pre><code>let func = new Function ([arg1, arg2, ...argN], functionBody);</code></pre>
      <p>
        По историческим причинам аргументы также могут быть объявлены через
        запятую в одной строке.
      </p>
      <p>Эти 3 объявления ниже эквивалентны:</p>
      <pre><code>new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке</code></pre>
      <p>
        Функции, объявленные через <code>new Function</code>, имеют
        <code>[[Environment]]</code>, ссылающийся на глобальное лексическое
        окружение, а не на родительское. Поэтому они не могут использовать
        внешние локальные переменные. Но это очень хорошо, потому что страхует
        нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное
        решение, которое не вызывает проблем у минификаторов.
      </p>
    </div>
  </div>
  <div class="card mb-3" id="settimeout-setinterval">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.8 Планирование: setTimeout и setInterval</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton8"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton8">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-8-1.html"
            >1</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a
          href="https://learn.javascript.ru/settimeout-setinterval"
          target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <ul>
        <li>
          Методы <code>setInterval(func, delay, ...args)</code> и
          <code>setTimeout(func, delay, ...args)</code> позволяют выполнять
          <code>func</code> регулярно или только один раз после задержки
          <code>delay</code>, заданной в мс.
        </li>
        <li>
          Для отмены выполнения необходимо вызвать
          <code>clearInterval/clearTimeout</code> со значением, которое
          возвращают методы <code>setInterval/setTimeout</code>.
        </li>
        <li>
          Вложенный вызов <code>setTimeout</code> является более гибкой
          альтернативой <code>setInterval</code>. Также он позволяет более точно
          задать интервал между выполнениями.
        </li>
        <li>
          Планирование с нулевой задержкой <code>setTimeout(func,0)</code> или,
          что то же самое, <code>setTimeout(func)</code> используется для
          вызовов, которые должны быть исполнены как можно скорее, после
          завершения исполнения текущего кода.
        </li>
        <li>
          Браузер ограничивает 4-мя мс минимальную задержку между пятью и более
          вложенными вызовами <code>setTimeout</code>, а также для
          <code>setInterval</code>, начиная с 5-го вызова.
        </li>
      </ul>
      <p>
        Обратим внимание, что все методы планирования
        <em>не гарантируют</em> точную задержку.
      </p>
      <p>Например, таймер в браузере может замедляться по многим причинам:</p>
      <ul>
        <li>Перегружен процессор.</li>
        <li>Вкладка браузера в фоновом режиме.</li>
        <li>Работа ноутбука от аккумулятора.</li>
      </ul>
      <p class="mb-0">
        Всё это может увеличивать минимальный интервал срабатывания таймера (и
        минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера
        и настроек производительности ОС.
      </p>
    </div>
  </div>
  <div class="card mb-3" id="call-apply-decorators">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.9 Декораторы и переадресация вызова, call/apply</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton9"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton9">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-9-1.html"
            >1</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-9-2.html"
            >2</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-9-3.html"
            >3</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-9-4.html"
            >4</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a
          href="https://learn.javascript.ru/call-apply-decorators"
          target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <p>
        <em>Декоратор</em> – это обёртка вокруг функции, которая изменяет
        поведение последней. Основная работа по-прежнему выполняется функцией.
      </p>
      <p>
        Обычно безопасно заменить функцию или метод декорированным, за
        исключением одной мелочи. Если исходная функция предоставляет свойства,
        такие как <code>func.calledCount</code> или типа того, то декорированная
        функция их не предоставит. Потому что это обёртка. Так что нужно быть
        осторожным в их использовании. Некоторые декораторы предоставляют свои
        собственные свойства.
      </p>
      <p>
        Декораторы можно рассматривать как «дополнительные возможности» или
        «аспекты», которые можно добавить в функцию. Мы можем добавить один или
        несколько декораторов. И всё это без изменения кода оригинальной
        функции!
      </p>
      <p>Для реализации <code>cachingDecorator</code> мы изучили методы:</p>
      <ul>
        <li>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call"
            >func.call(context, arg1, arg2…)</a
          >
          – вызывает <code>func</code> с данным контекстом и аргументами.
        </li>
        <li>
          <a
            href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"
            >func.apply(context, args)</a
          >
          – вызывает <code>func</code>, передавая <code>context</code> как
          <code>this</code> и псевдомассив <code>args</code> как список
          аргументов.
        </li>
      </ul>
      <pre><code>let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

alert( worker.slow(2) ); // работает
alert( worker.slow(2) ); // работает, не вызывая первоначальную функцию (кешируется)
</code></pre>
      <p>
        В основном <em>переадресация вызова</em> выполняется с помощью
        <code>apply</code>:
      </p>
      <pre><code>let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};</code></pre>
      <p>
        Мы также рассмотрели пример <em>заимствования метода</em>, когда мы
        вызываем метод у объекта в контексте другого объекта. Весьма
        распространено заимствовать методы массива и применять их к
        <code>arguments</code>. В качестве альтернативы можно использовать
        объект с остаточными параметрами <code>...args</code>, который является
        реальным массивом.
      </p>
      <p>
        На практике декораторы используются для самых разных задач. Проверьте,
        насколько хорошо вы их освоили, решая задачи этой главы.
      </p>
      <pre class="ml-0"><code>function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);</code></pre>
    </div>
  </div>
  <div class="card mb-3" id="bind">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.9 Привязка контекста к функции</h2>
      <div class="dropdown ml-auto">
        <button
          class="btn btn-primary dropdown-toggle"
          type="button"
          id="dropdownMenuButton10"
          data-toggle="dropdown"
          aria-haspopup="true"
          aria-expanded="false"
        >
          Homeworks
        </button>
        <div class="dropdown-menu" aria-labelledby="dropdownMenuButton10">
          <a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-10-1.html"
            >1</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-10-2.html"
            >2</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-10-3.html"
            >3</a
          ><a
            class="dropdown-item"
            target="_blank"
            href="./homeworks/6/6-10-4.html"
            >4</a
          >
        </div>
      </div>
      <div class="ml-4">
        <a href="https://learn.javascript.ru/bind" target="_blank">Link</a>
      </div>
    </div>
    <div class="card-body">
      <p>
        Метод <code>bind</code> возвращает «привязанный вариант» функции
        <code>func</code>, фиксируя контекст <code>this</code> и первые
        аргументы <code>arg1</code>, <code>arg2</code>…, если они заданы.
      </p>
      <p>
        Контекст связанной функции жёстко фиксирован. Изменить однажды
        привязанный контекст уже нельзя.
      </p>
      <pre><code>let user = {
  firstName: "Вася"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // Вася
</code></pre>
      <p>
        Обычно <code>bind</code> применяется для фиксации <code>this</code> в
        методе объекта, чтобы передать его в качестве колбэка. Например, для
        <code>setTimeout</code>.
      </p>
      <pre><code>let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

let sayHi = user.sayHi.bind(user); // (*)

sayHi(); // Привет, Вася!

setTimeout(sayHi, 1000); // Привет, Вася!</code></pre>
      <p>
        Когда мы привязываем аргументы, такая функция называется «частично
        применённой» или «частичной».
      </p>
      <p>
        Частичное применение удобно, когда мы не хотим повторять один и тот же
        аргумент много раз. Например, если у нас есть функция
        <code>send(from, to)</code> и <code>from</code> всё время будет одинаков
        для нашей задачи, то мы можем создать частично применённую функцию и
        дальше работать с ней.
      </p>
      <pre><code>function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10</code></pre>
      <p>
        Экзотический объект bound function, возвращаемый при первом вызове
        f.bind(...), запоминает контекст (и аргументы, если они были переданы)
        только во время создания. Следующий вызов bind будет устанавливать
        контекст уже для этого объекта. Это ни на что не повлияет.
      </p>
      <pre class="mb-0"><code>function f() {
  alert(this.name);
}

f = f.bind( {name: "Вася"} ).bind( {name: "Петя"} );

f(); // Вася</code></pre>
    </div>
  </div>
  <div class="card mb-3" id="arrow-functions">
    <div class="card-header d-flex align-items-center">
      <h2 class="h5 mb-0">6.10 Повторяем стрелочные функции</h2>

      <div class="ml-auto">
        <a href="https://learn.javascript.ru/arrow-functions" target="_blank"
          >Link</a
        >
      </div>
    </div>
    <div class="card-body">
      <ul>
        <li>Не имеют <code>this</code>.</li>
        <li>Не имеют <code>arguments</code>.</li>
        <li>Не могут быть вызваны с <code>new</code>.</li>
        <li>
          (У них также нет <code>super</code>, но мы про это не говорили. Про
          это будет в главе
          <a href="/class-inheritance">Наследование классов</a>).
        </li>
      </ul>
      <p>
        Всё это потому, что они предназначены для небольшого кода, который не
        имеет своего «контекста», выполняясь в текущем. И они отлично
        справляются с этой задачей!
      </p>
    </div>
  </div>
</div>
